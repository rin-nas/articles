
# Сравнение SQL шаблонизатора vs ORM или QueryBuilder

## Введение
Принцип [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)) утверждает, что большинство систем работают лучше всего, если они остаются простыми, а не усложняются. В области проектирования IT решений простота должна быть одной из ключевых целей, и следует избегать ненужной сложности.

* Описание принципов работы [SQL шаблонизатора](https://github.com/rin-nas/sql-template-engine/blob/master/README.md)
* По [ORM](https://ru.wikipedia.org/wiki/ORM) ознакомьтесь [с этой статьёй на Хабре](https://m.habr.com/company/pgdayrussia/blog/328690/).
* По QueryBuilder ознакомьтесь с разделом документации [Laravel](http://laravel.su/docs/5.5/queries) и/или [Doctrine](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html).

## Сокращения
* ORM — Object-Relational Mapping
* QB — QueryBuilder

## Таблица сравнения
\#| Критерий | SQL шаблонизатор | ORM или QueryBuilder
--|----------|------------------|---------------------
1 | Порог вхождения программиста перед началом работы| Меньше. Достаточно изучить несколько простых типов меток-заменителей и одно правило условного блока| Больше. Нужно изучить десятки методов с их параметрами
2 | Перегенерация моделей каждый раз при изменении схемы БД| Не нужно | Нужно. Это занимает лишнее время, в логике генератора могут быть ошибки.
3 | Скорость генерации SQL | Быстрее. Простой парсер без использования регулярных выражений работает очень быстро. Парсер на базе рег. выражений работает не медленнее ORM или QB | Медленнее. Ещё один слой абстакции с дополнительной логикой, которая может содержать ошибки
4 | Оптимальность генерации sql | Да. Выполяется именно тот запрос, который задумал разработчик. | Нет. Вместо 1 sql запроса их может быть десятки, что плохо сказывается на общем времени выполнения
5 | Размер исходного кода | 10К | 50К и более. Как правило, больший размер кода содержит больше ошибок
6 | Быстрое создание нового запроса к БД | Да. Только расстановка меток-заменителей в SQL запросе | Нет. Необходимо переписывать SQL запрос после его создания в набор методов ORM/QB, это лишние затраты времени
7 | Быстрая модификация существующего запроса к БД | Да. SQL запрос можно дописать сколько угодно сложным SQL кодом. | Нет. При усложнении логики возможностей ORM уже не хватает и тогда нужно переписывать обратно в SQL. Сложный запрос в QB может стать слабо читабельным и трудноподдерживаемым
8 | Результат в виде вложенных объектов | Да. За 1 SQL запрос можно получить результат сколь угодно сложной структуры, возвращая [JSON](https://ru.wikipedia.org/wiki/JSON) и затем декодируя его. По сути это аналог объектов, хотя и не полноценный (есть свойства, но нет методов). Но методы могут не понадобиться так так все данные, скорее всего уже получены в 1-м SQL запросе. При острой необходимости можно сделать экспорт данных в полноценные объекты | Да. Но на каждый объект будет как минимум 1 SQL запрос, что плохо скажется на производителности
9 | Кэширование запросов (в памяти) | Нет встроенного механизма кеширования | ORM или QB могут иметь встроенные механизмы кеширования
10 | Скорость (а так же удобство и гибкость) разработки | Хуже. Могут присутствовать дубликаты SQL кода. В случае изменения логики нужно править во многих местах. Но в этом случае такая множественная правка будет одновременно валидацией необходимости правок в каждом месте | Лучше. Одинаковые части выносятся в отдельные методы объектов. С объектами легче манипулировать

## Итого в сухом остатке

\#| Критерий                      | SQL шаблонизатор | ORM или QueryBuilder | Степень отличия
--|-------------------------------|------------------|----------------------|------------------
1 | Общая скорость разработки     | Медленнее        | Быстрее              | не значительно
2 | Общая производительность кода | Быстрее          | Медленнее            | может быть в разы
3 | Общая стабильность кода       | Лучше            | Хуже                 | может быть в разы
